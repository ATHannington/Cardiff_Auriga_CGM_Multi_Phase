#===============================================================================#
#-------------------------------------------------------------------------------#
#		PlotProbabilities.py                                                    #
#		Plots the emission probabilities as generated by RadTrans_MainCode.F90  #
#		Details of this program below.                                          #
#-------------------------------------------------------------------------------#
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import math
import datetime
import os
from astropy import units as u

now = datetime.datetime.now()

print ()
print ("Current date and time using str method of datetime object:")
print (str(now))


##
date_last_edited= "18/04/2019"													#PLEASE KEEP THIS UP-TO-DATE!!                                                #

																				#Input directory into which to save plots here                                #
savepath = "C:/Users/C1838736/Documents/ATH_PhD/_PhD_Output/" + \
"Cylindrically_Symmetric_Filament_MCRT/"
																				#    Note: if func_datetime_savepath used, a subdirectory will be made here   #
																				#      using today's date at runtime.                                         #

#------------------------------------------------------------------------------#
#Files for data to be imported for plotting.                                   #
lambdaDataPath  = "WLData.csv"
#Black Body Data:
BBconstantsPath = "BBconstants.csv"
BBAnalyticPath  = "BBAnalytic.csv"
BBmcrtPath 		= "BBMCRT.csv"
#Modified Black Body data:
MBconstantsPath = "MBconstants.csv"
MBAnalyticPath  = "MBAnalytic.csv"
MBmcrtPath 		= "MBMCRT.csv"
#Differential Modified Black Body data:
DMconstantsPath = "DMconstants.csv"
DMAnalyticPath  = "DMAnalytic.csv"
DMmcrtPath 		= "DMMCRT.csv"


##

#-------------------------------------------------------------------------------#
#-------------------------------------------------------------------------------#

# !!!
author= "Andrew T. Hannington"
email= "HanningtonAT@cardiff.ac.uk"
affiliation= "Cardiff University, Wales, UK"

adapted_from_author = "Prof. A.P. Whitworth"
adapted_from_email = "anthony.whitworth@cardiff.ac.uk"
adapted_from_affiliation = "Cardiff University, Wales, UK"

date_created= "12/04/2019"

#
# Notes: Python program for plotting emission probabilities from 
# 		 Prof. A. P. Whitworth's RadTrans MCRT code for Radially Symmetric 
#		 Filamentary Molecular Clouds.
#		 Equivalent subroutine in A.P.W's code:
#		 # SUBROUTINE RT_EmProbs_DMBB(TEkTOT,teT,WLlTOT,WLlam,WLdlam,WLchi,\
#			WLalb,PRnTOT,WTpack,WTplot,WTpBB,WTlBBlo,WTlBBup,WTpMB,WTlMBlo, \
#			WTlMBup,teLMmb,WTpDM,WTlDMlo,WTlDMup,teLMTdm)
#
#-------------------------------------------------------------------------------#
#-------------------------------------------------------------------------------#

#-------------------------------------------------------------------------------#
#		Below are functions etc. used by this program                           #
#                                                                               #
#                                                                               #


#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -#
def func_datetime_savepath (input_savepath_string):
	"""
	Description: Function for generating a savepath string and creating 
				subsequent directory.
				NOTE: this function will NOT create all intermediate level 
				directories in path name. To do this, please see Python 
				documentation on os.makedirs()
	Inputs:		Var: input_savepath_string	Type:string 	Dtype: char
	Outputs:	Var: savepath				Type: string	Dtype: char
				------
	Notes:		Created 09/04/2019 by ATH. Working as of 09/04/2019
	"""
	
	save_date = str(now.strftime("%Y-%m-%d-%H-%M"))
	savepath = input_savepath_string + "/" + save_date +"/"
	print()
	print("Savepath generated! Datetime used!")
	os.mkdir(savepath)
	print("Directory created at savepath!")
	print("Your savepath directory path is:")
	print(savepath)
	print()
	return savepath

#-------------------------------------------------------------------------------#
#		Below is the beginning of the program which writes to screen the        #
#		information about authors etc. above.                                   #
#                                                                               #
#                                                                               #
print("*****")
print()
print("**Plot Emission Probabilities Program**")
print()
print(f"Author: {author}")
print(f"Email: {email}")
print(f"Affiliation: {affiliation}")
print()
print(f"Adapted from work by: {adapted_from_author}")
print(f"Email: {adapted_from_email}")
print(f"Affiliation: {adapted_from_affiliation}")
print()
print(f"Program first created: {date_created}")
print(f"Program last edited: {date_last_edited}")
print()
print("*****")
print()

del author, email, affiliation, adapted_from_affiliation, adapted_from_author \
,adapted_from_email, date_created, date_last_edited								#Clear preamble variables from memory                                         #

#-------------------------------------------------------------------------------#
#		Begin Program by loading in data from RadTrans_MainCode.F90.            #
#                                                                               #
#                                                                               #

lambdaData 	 = np.loadtxt(lambdaDataPath)

###Load into Data frame, omit header for data, skip spaces, and tranpose for ease of plotting
BBconstants  = pd.read_csv(BBconstantsPath,delimiter=" ")			#We read the data into a Pandas Data Frame                                    #
BBAnalytic	 = pd.read_csv(BBAnalyticPath,delimiter=" ",header=None, \
skipinitialspace =True).T
BBMCRT		 = pd.read_csv(BBmcrtPath,delimiter=" ",header=None, \
skipinitialspace =True).T

MBconstants  = pd.read_csv(MBconstantsPath,delimiter=" ")								#We read the data into a Pandas Data Frame                                    #
MBAnalytic	 = pd.read_csv(MBAnalyticPath,delimiter=" ",header=None, \
skipinitialspace =True).T
MBMCRT		 = pd.read_csv(MBmcrtPath,delimiter=" ",header=None, \
skipinitialspace =True).T

DMconstants  = pd.read_csv(DMconstantsPath,delimiter=" ")								#We read the data into a Pandas Data Frame                                    #
DMAnalytic	 = pd.read_csv(DMAnalyticPath,delimiter=" ",header=None, \
skipinitialspace =True).T
DMMCRT		 = pd.read_csv(BBmcrtPath,delimiter=" ",header=None, \
skipinitialspace =True,).T




###
###Cut off end NaN from Fortran Carriage Return Space
###
BBAnalytic.drop(BBAnalytic.tail(1).index,inplace=True)
BBMCRT.drop(BBMCRT.tail(1).index,inplace=True)
MBAnalytic.drop(MBAnalytic.tail(1).index,inplace=True)
MBMCRT.drop(MBMCRT.tail(1).index,inplace=True)
DMAnalytic.drop(DMAnalytic.tail(1).index,inplace=True)
DMMCRT.drop(DMMCRT.tail(1).index,inplace=True)


###Replace all values with float64 and "coerce" unrecognised into NaNs
for cols in BBAnalytic.columns.values:
	BBAnalytic[cols] = pd.to_numeric(BBAnalytic[cols], errors='coerce')
	BBMCRT[cols] = pd.to_numeric(BBMCRT[cols], errors='coerce')
	MBAnalytic[cols] = pd.to_numeric(MBAnalytic[cols], errors='coerce')
	MBMCRT[cols] = pd.to_numeric(MBMCRT[cols], errors='coerce')
	DMAnalytic[cols] = pd.to_numeric(DMAnalytic[cols], errors='coerce')
	DMMCRT[cols] = pd.to_numeric(DMMCRT[cols], errors='coerce')

#-------------------------------------------------------------------------------#

# print()
# print("***")
# print("Data Details (for debugging):")
# print()
# print()
# print("Wavelength:")
# print(lambdaData,np.shape(lambdaData))
# print()
# print("BB:")
# print("Constants:",BBconstants,np.shape(BBconstants),BBconstants.columns.values)
# print("Analytic:",BBAnalytic,np.shape(BBAnalytic),BBAnalytic.columns.values)
# print("MCRT:",BBMCRT,np.shape(BBMCRT),BBMCRT.columns.values)
# print()
# print("MB:")
# print("Constants:",MBconstants,np.shape(MBconstants),MBconstants.columns.values)
# print("Constants:",MBconstants,np.shape(MBconstants),MBconstants.columns.values)
# print("Analytic:",MBAnalytic,np.shape(MBAnalytic),MBAnalytic.columns.values)
# print("MCRT:",MBMCRT,np.shape(MBMCRT),MBMCRT.columns.values)
# print()
# print("DM(BB):")
# print("Constants:",DMconstants,np.shape(DMconstants),DMconstants.columns.values)
# print("Analytic:",DMAnalytic,np.shape(DMAnalytic),DMAnalytic.columns.values)
# print("MCRT:",DMMCRT,np.shape(DMMCRT),DMMCRT.columns.values)


fig = plt.figure()
for i in range(0, len(BBconstants['temp'])):
	plt.plot(lambdaData,BBAnalytic[i], color="black", label=f"BB Analytic T={BBconstants['temp'][i]}")
	plt.plot(lambdaData,BBMCRT[i],color="red",label=f"BB MCRT T={BBconstants['temp'][i]}")
fig.legend()

fig = plt.figure()
for i in range(0, len(MBconstants['temp'])):
	plt.plot(lambdaData,MBAnalytic[i], color="black",label=f"MB Analytic T={BBconstants['temp'][i]}")
	plt.plot(lambdaData,MBMCRT[i], color="red",label=f"MB MCRT T={BBconstants['temp'][i]}")
fig.legend()

fig = plt.figure()
for i in range(0, len(MBconstants['temp'])):
	plt.plot(lambdaData,MBAnalytic[i],color="black", label=f"DM Analytic T={BBconstants['temp'][i]}")
	plt.plot(lambdaData,MBMCRT[i],color="red", label=f"DM MCRT T={BBconstants['temp'][i]}")
fig.legend()
plt.show()

