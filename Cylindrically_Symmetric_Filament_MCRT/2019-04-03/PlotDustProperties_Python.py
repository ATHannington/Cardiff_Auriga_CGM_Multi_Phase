#-------------------------------------------------------------------------------#
#		PlotDustProperties.py                                                   #
#		Plots the properties of dust as generated by RadTrans_MainCode.F90      #
#		Details of this program below.                                          #
#-------------------------------------------------------------------------------#
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import math

# print(np.__version__)

# !!!
author= "Andrew T. Hannington"
email= "HanningtonAT@cardiff.ac.uk"
affiliation= "Cardiff University, Wales, UK"

adapted_from_author = "Prof. A.P. Whitworth"
adapted_from_email = "anthony.whitworth@cardiff.ac.uk"
adapted_from_affiliation = "Cardiff University, Wales, UK"

date_created= "05/04/2019"

#
# Notes: Python program for plotting dust properties from 
# 		 Prof. A. P. Whitworth's RadTrans MCRT code for Radially Symmetric 
#		 Filamentary Molecular Clouds.
#		 Equivalent subroutine in A.P.W's code:
#		 # SUBROUTINE RT_PlotDustProperties(WLlTOT,WLlam,WLchi,WLalb)
#
##
##
date_last_edited= "08/04/2019"													#PLEASE KEEP THIS UP-TO-DATE!!                                                #
##
##

#!!!


#-------------------------------------------------------------------------------#
#		Below is the beginning of the program which writes to screen the        #
#		information inputted above.                                             #
#                                                                               #
#                                                                               #
print("*****")
print()
print("**Plot Dust Properties Program**")
print()
print(f"Author: {author}")
print(f"Email: {email}")
print(f"Affiliation: {affiliation}")
print()
print(f"Adapted from work by: {adapted_from_author}")
print(f"Email: {adapted_from_email}")
print(f"Affiliation: {adapted_from_affiliation}")
print()
print(f"Program first created: {date_created}")
print(f"Program last edited: {date_last_edited}")
print()
print("*****")
print()

del author, email, affiliation, adapted_from_affiliation, adapted_from_author \
,adapted_from_email, date_created, date_last_edited								#Clear preamble variables from memory                                         #

#-------------------------------------------------------------------------------#
#		Begin Program by loading in data from RadTrans_MainCode.F90.            #
#                                                                               #
#                                                                               #
importstring = "DustProperties.csv"

read_data = pd.read_csv(importstring,delimiter=" ")								#We read the data into a Pandas Data Frame                                    #

print()
print("File read from:", importstring)
del importstring																#Clear importstring from memory                                               #
print("Data Frame shape:")
print(read_data.shape)															#Confirm data is of correct shape                                             #

print()

																				#Create lists of Log10(Lambda),                                                #
#print("Test! lam(0)=", read_data['lam'][0])
x_lamLog10= [math.log10(read_data['lam'][i]) for i in \
range(0,len(read_data['lam']),1)] 
#print("Test! Log10(lam(0))=", x_lamLog10[0])

																				#    and of Log10(Chi).                                                       #
#print("Test! chi(0)=", read_data['chi'][0])
y_chiLog10= [math.log10(read_data['chi'][i]) for i in \
range(0,len(read_data['chi']),1)] 
#print("Test! Log10(chi(0))=", y_chiLog10[0])

xmin = min(x_lamLog10)															#         then find max and min values for each, to use for axes in plots.    #
xmax = max(x_lamLog10)
ymin = min(y_chiLog10)
ymax = max(y_chiLog10)

																				#Create a list of 10 times the albedo. This is used to bring the Albedo up to #
																				#    a comparable scale with Log10(chi) and Log10(lambda).                    #

z_10alb = [(10.*read_data['alb'][i]) for i in \
range(0,len(read_data['alb']),1)]

zmin = min(z_10alb)
zmax = max(z_10alb)

deltafrac = 0.1																	#Set some fraction of delta x or y (max-min) to pad axes by.                  #

deltax = deltafrac*(xmax-xmin)													#Compute updated xmin, xmax, ymin, ymax, updated by axis padding.             #
xmax = xmax + deltax
xmin = xmin - deltax
deltay = deltafrac*(ymax-ymin)
ymax = ymax + deltay
ymin = ymin - deltay
deltaz = deltafrac*(zmax-zmin)
zmax = zmax + deltaz
zmin = zmin - deltaz


del deltafrac,deltax,deltay,deltaz												#Clear deltafrac, deltax, deltay from memory                                  #

#-------------------------------------------------------------------------------#
#		Data manipulation complete.                                             #
#           Begin Plotting!                                                     #
#                                                                               #
#		Much of the following has been adapted from the Matplotlib documentation#
#                                                                               #

fig, ax1 = plt.subplots()														#Start new fig and axis with plt.subplots()                                   #

color = 'red'																	#Set first colour                                                             #
plot2 = ax1.plot(x_lamLog10, y_chiLog10, color=color, label = "Chi")			#    Plot Log10(Chi) against Log10(Lambda), in above colour, with legend label#
																				#    "chi".
ax1.set_xlim(xmin,xmax)															#        Set axes to have max and min values as calculated                    #
ax1.set_ylim(ymin,ymax)
ax1.set_xlabel("Log10(Lambda)   [ Log10(microns) ]")							#            Set x axis label, with units                                     #
ax1.set_ylabel("Log10(Chi)   [ Log10(cm^2 / g) ]",color=color)					#                Set y axis label, with units, in color defined above.        #

ax2 = ax1.twinx()																#Set second axis plot to have a twin of the first's x-axis.                   #

color='blue'
																				#Plot 10*Albedo against Log10(Lambda), dashed, in colour 2, legend label      #
																				#  "Albedo".
plot1 = ax2.plot(x_lamLog10, z_10alb,color=color, linestyle="-" ,\
label = "Albedo")
ax2.set_xlim(xmin,xmax)															#    Set axes limits to min  and max of new variables                         #
ax2.set_ylim(zmin,zmax)															
ax2.set_xlabel("Log10(Lambda)   [ Log10(microns) ]")							#        Set axis labels, with units.                                         #
ax2.set_ylabel("10*Albedo   [Unitless]", color=color)

fig.legend(bbox_to_anchor=(.85,.9), loc="upper right", borderaxespad=0.)		#Attach Legend to image, in adjusted upper right [NOTE: Standard Upper Right  #
																				#  does not work here. Ejects image out of frame, overlapping with 2nd y-axis #
																				#    tickers]. We have added "borderaxespad=0." to remind self option exists. #
fig.tight_layout()																#According to Maplotlib documentation this line is needed to ensure the second#
																				#  axis does not become clipped.                                              #
plt.show()																		#Show figure!                                                                 #




print("END")																	#----  END OF PROGRAM !! ----                                                 #
#WLlTOT = len()

# !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# SUBROUTINE RT_PlotDustProperties(WLlTOT,WLlam,WLchi,WLalb)
# !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# ! This subroutine plots the optical properties of the dust grains, and 
# ! modified Planck spectra at a selection of temperatures. It is given:
# !   the number of wavelengths            (WLlTOT);   
# !   the discrete wavelengths             (WLlam(1:WLlTOT)); 
# !   the discrete extinction opacities    (WLchi(1:WLlTOT)); 
# !   and the discrete albedos             (WLalb(1:WLlTOT)).

# IMPLICIT NONE                                            ! [] DECLARATIONS
# INTEGER,     INTENT(IN)                     :: WLlTOT    ! the number of discrete wavelengths
# REAL(KIND=8),INTENT(IN),DIMENSION(1:WLlTOT) :: WLlam     ! the discrete  wavelengths
# REAL(KIND=8),INTENT(IN),DIMENSION(1:WLlTOT) :: WLchi     ! the discrete extinction opacities
# REAL(KIND=8),INTENT(IN),DIMENSION(1:WLlTOT) :: WLalb     ! the discrete albedos
# INTEGER                                     :: TEk       ! a dummy temperature ID
# REAL(KIND=8),DIMENSION(1:5)                 :: teT       ! the prescribed temperatures
# INTEGER                                     :: WLl       ! a dummy wavelength ID
# REAL(KIND=8)                                :: WLlamMAX  ! the maximum wavelength
# REAL(KIND=8)                                :: WLlamMIN  ! the minimum wavelength
# REAL(KIND=8)                                :: ZZdumR    ! a dummy real
                                                         # ! FOR PGPLOT
# REAL(KIND=4),DIMENSION(1:WLlTOT)            :: PGx       ! array for abscissa (log10[lam])
# REAL(KIND=4)                                :: PGxMAX    ! upper limit on abscissa
# REAL(KIND=4)                                :: PGxMIN    ! lower limit on abscissa
# REAL(KIND=4),DIMENSION(1:WLlTOT)            :: PGy       ! array for ordinate (log10[chi,PlanckFn])
# REAL(KIND=4)                                :: PGyMAX    ! upper limit on ordinate
# REAL(KIND=4)                                :: PGyMIN    ! lower limit on ordinate
# REAL(KIND=4),DIMENSION(1:WLlTOT)            :: PGz       ! array for ordinate (log10[alb,VolEm])
# REAL(KIND=4)                                :: PGzMAX    ! upper limit on ordinate
# REAL(KIND=4)                                :: PGzMIN    ! lower limit on ordinate

                                                         # ! [] DUST PROPERTIES
# PGxMIN=+0.1E+11                                          ! set PGx_MIN to improbably high value
# PGxMAX=-0.1E+11                                          ! set PGx_MAX to improbably low value
# PGyMIN=+0.1E+11                                          ! set PGy_MIN to improbably high value
# PGyMAX=-0.1E+11                                          ! set PGy_MAX to improbably low value
# DO WLl=1,WLlTOT                                          ! start loop over wavelengths
  # PGx(WLl)=LOG10(WLlam(WLl))                             !   compute LOG10[lam]
  # IF (PGx(WLl)<PGxMIN) PGxMIN=PGx(WLl)                   !   reduce PGx_MIN, as appropriate
  # IF (PGx(WLl)>PGxMAX) PGxMAX=PGx(WLl)                   !   increase PGx_MAX, as appropriate
  # PGy(WLl)=LOG10(WLchi(WLl))                             !   compute LOG10[chi]
  # IF (PGy(WLl)<PGyMIN) PGyMIN=PGy(WLl)                   !   reduce PGy_MIN, as appropriate
  # IF (PGy(WLl)>PGyMAX) PGyMAX=PGy(WLl)                   !   increase PGy_MAX, as appropriate
  # PGz(WLl)=10*WLalb(WLl)                                 !   compute 10 x alb
# ENDDO                                                    ! end loop over wavelengths
##
##
##
##
# ZZdumR=0.1*(PGxMAX-PGxMIN)                               ! compute margin for abscissa
# PGxMIN=PGxMIN-ZZdumR                                     ! compute minimum abscissa
# PGxMAX=PGxMAX+ZZdumR                                     ! compute maximum abscissa
# ZZdumR=0.1*(PGyMAX-PGyMIN)                               ! compute margin for ordinate
# PGyMIN=PGyMIN-ZZdumR                                     ! compute minimum ordinate
# PGyMAX=PGyMAX+ZZdumR                                     ! compute maximum ordinate
##
##
##
##
# WRITE (*,*) ' '                                          ! print blank line
# CALL PGBEG(0,'/XWINDOW',1,1)                             ! open PGPLOT to display on screen
# !CALL PGBEG(0,'/PS',1,2)                                  ! open PGPLOT to produce postscript
# CALL PGSLW(1)                                            ! select line weight
# CALL PGSCH(0.9)                                          ! select character height
# CALL PGENV(PGxMIN,PGxMAX,PGyMIN,PGyMAX,0,0)              ! construct frame
# CALL PGLAB('log\d10\u[\gl/\gmm]','     log\d10\u[\gx/cm\u2\dg\u-1\d]  and  10\fia',&
     # &'DUST EXTINCTION OPACITY, \gx, AND ALBEDO, \fia\fn, AS A FUNCTION OF WAVELENGTH, \gl.')
# CALL PGSLS(1)                                            ! select full line
# CALL PGLINE(WLlTOT,PGx,PGy)                              ! plot extinction curve
# CALL PGSLS(2)                                            ! select dashed line
# CALL PGLINE(WLlTOT,PGx,PGz)                              ! plot 10 x albedo
# PGx(1)=-1.00; PGx(2)=+0.00                               ! set limiting abscissae of lines
# PGy(1)=-2.70; PGy(2)=-2.70                               ! set limiting ordinates of extinction full-line legend
# PGz(1)=-3.80; PGz(2)=-3.80                               ! set limiting ordinates of albedo dashed-line legend
# CALL PGSLS(1)                                            ! select full line
# CALL PGLINE(2,PGx,PGy)                                   ! draw full line
# CALL PGTEXT(+0.30,-2.80,'DUST EXTINCTION OPACITY,')      ! print extinction ...
# CALL PGTEXT(+1.05,-3.20,'log\d10\u[\gx/cm\u2\dg\u-1\d]') ! ... full-line legend
# CALL PGSLS(2)                                            ! select dashed line
# CALL PGLINE(2,PGx,PGz)                                   ! draw dashed line
# CALL PGTEXT(+0.30,-3.90,'DUST ALBEDO, 10\fia\fn')        ! print albedo dashed-line legend
# CALL PGEND                                               ! close PGPLOT
# WRITE (*,*) ' '                                          ! print blank line

                                                         # ! [] PLANCK FUNCTIONS AND VOLUME EMISSIVITIES
# teT(1)=3.16; teT(2)=10.0; teT(3)=31.6; teT(4)=100.; teT(5)=316. ! input selected temperatures
# CALL PGBEG(0,'/XWINDOW',1,1)                             ! open PGPLOT to display on screen
# !CALL PGBEG(0,'/PS',1,2)                                  ! open PGPLOT to produce postscript
# CALL PGENV(0.2,4.6,-4.2,+0.6,0,0)                        ! construct frame
# CALL PGLAB('      log\d10\u[\gl/\gmm]','       log\d10\u[\fiB\fn\d\gl\u(\fiT\fn)]  and  log\d10\u[\fij\fn\d\gl\u(\fiT\fn)]',&
# &'PLANCK FUNCTION, \fiB\fn\d\gl\u(\fiT\fn), AND VOLUME EMISSIVITY, \fij\fn\d\gl\u(\fiT\fn), AS A FUNCTION OF WAVELENGTH, \gl. ')
# DO TEk=1,5                                               ! start loop over temperatures
  # ZZdumR=(0.143878E+05)/teT(TEk)                         !   compute lambda_T=hc/kT
  # WLlamMIN=0.03*ZZdumR                                   !   compute minimum significant wavelength
  # WLlamMAX=10.0*ZZdumR                                   !   compute maximum significant wavelength
  # PGyMAX=-0.1E+21                                        !   set PGyMAX to absurdly low value
  # PGzMAX=-0.1E+21                                        !   set PGzMAX to absurdly low value
  # PGy=-0.2E+21                                           !   set all PGy to even lower value
  # PGz=-0.2E+21                                           !   set all PGz to even lower value
  # DO WLl=1,WLlTOT                                        !   start loop over wavelengths
    # IF (WLlam(WLl)<WLlamMIN) CYCLE                       !     [IF] wavelength very low, [CYCLE]
    # IF (WLlam(WLl)>WLlamMAX) CYCLE                       !     [IF] wavelength very high, [CYCLE]
    # PGy(WLl)=1./                                        &!     compute ...........
           # &(WLlam(WLl)**5*(EXP(ZZdumR/WLlam(WLl))-1.))  !     ... Planck Function
    # PGz(WLl)=PGy(WLl)*WLchi(WLl)*(1.-WLalb(WLl))         !     compute volume emissivity
    # PGy(WLl)=LOG10(PGy(WLl))                             !     compute LOG(PGy)
    # PGz(WLl)=LOG10(PGz(WLl))                             !     compute LOG(PGz)
    # IF (PGy(WLl)>PGyMAX) PGyMAX=PGy(WLl)                 !     update PGyMAX, as appropriate
    # IF (PGz(WLl)>PGzMAX) PGzMAX=PGz(WLl)                 !     update PGzMAX, as appropriate
  # ENDDO                                                  !   end loop over wavelengths
  # PGy=PGy-PGyMAX                                         !   normalise PGy
  # PGz=PGz-PGzMAX                                         !   normalise PGz
  # CALL PGSLS(2)                                          !   invoke dashed line
  # CALL PGLINE(WLlTOT,PGx,PGy)                            !   plot Planck Function
  # CALL PGSLS(1)                                          !   invoke full line
  # CALL PGLINE(WLlTOT,PGx,PGz)                            !   plot volume emissivity
  # CALL PGTEXT(+0.85,+0.13,'316.K')                       !   label 316.K plots
  # CALL PGTEXT(+1.30,+0.13,'100.K')                       !   label 100.K plots
  # CALL PGTEXT(+1.75,+0.13,'31.6K')                       !   label 31.6K plots
  # CALL PGTEXT(+2.25,+0.13,'10.0K')                       !   label 10.0K plots
  # CALL PGTEXT(+2.75,+0.13,'3.16K')                       !   label 3.16K plots
  # CALL PGTEXT(+3.60,+0.13,'\fiB\fn\d\gl\u(\fiT\fn)')     !   print Planck-Function dashed-line legend
  # CALL PGTEXT(+3.62,-0.13,'\fij\fn\d\gl\u(\fiT\fn)')     !   print volume-emissivity full-line legend
  # PGx(1)=+3.96; PGx(2)=+4.34                             !   set limiting abscissae of lines 
  # PGy(1)=+0.17; PGy(2)=+0.17                             !   set limiting ordinates of Planck-Function dashed-line
  # PGz(1)=-0.09; PGz(2)=-0.09                             !   set limiting ordinates of volume-emssivity full-line
  # CALL PGSLS(2)                                          !   select dashed line 
  # CALL PGLINE(2,PGx,PGy)                                 !   draw Planck-Function dashed line
  # CALL PGSLS(1)                                          !   select full line
  # CALL PGLINE(2,PGx,PGz)                                 !   draw volume-emissivity full line
# ENDDO                                                    ! end loop over temperatures
# CALL PGEND                                               ! close PGPLOT
# WRITE (*,*) ' '                                          ! print blank line

# !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# END SUBROUTINE RT_PlotDustProperties